# Detection and Analysis: Identifying and Eradicating Persistent Processes on Windows

## üõ°Ô∏è Strategic Introduction: The Imperative of Breaking Persistence

When a Windows system is successfully compromised, the threat actor's primary goal shifts from gaining access to maintaining access. They achieve this by establishing persistence, ensuring their malicious code‚Äîoften packaged as a seemingly legitimate service or process‚Äîruns automatically every time the machine starts or a user logs in.

The presence of a persistent, unwanted process or service is a high-fidelity Indicator of Compromise (IOC). While initial malware files (payloads) might be caught by antivirus, the running process allows the attacker to maintain a Command and Control (C2) channel, continuously communicating with external servers to receive new instructions, exfiltrate data, or deploy further malicious tools.

The ability to identify these running processes, pinpoint their exact location on the disk, and, most importantly, break the chain of persistence and communication, is crucial for effectively eradicating the threat. Without breaking persistence (e.g., removing the registry entry that forces the program to run), the malware will simply restart upon the next reboot, rendering any file deletion useless. Our goal is to surgically isolate the threat (Containment), remove the threat's executable and startup entries (Eradication), and ensure it can never run again.

---

## üéØ Project Goal

This project aims to equip you with the steps to:
*   Identify uncommon and potentially malicious running processes and their network activity on a Windows system.
*   Determine the exact executable path and owner of suspicious processes.
*   Check for and understand common persistence mechanisms used by malware.
*   Implement containment measures by blocking network access for malicious executables.
*   Perform eradication steps, including terminating processes, disabling persistence, and deleting malicious files.

---

## üìö Prerequisites

*   **Operating System:** A Windows 10 or Windows 11 machine (a virtual machine is highly recommended for safety and experimentation).
*   **Permissions:** Administrator privileges on the Windows system to run PowerShell scripts, modify registry, and manage services/firewall rules.
*   **Basic PowerShell Knowledge:** Familiarity with executing PowerShell scripts and understanding basic cmdlets (`Get-Process`, `Get-WmiObject`, `netstat`).
*   **Text Editor:** Any text editor (e.g., Notepad, VS Code) to copy and paste the scripts.
*   **Caution:** **Do NOT run these scripts on a production system or a system you are not authorized to modify. Using a dedicated virtual machine for testing is strongly advised.**

---

## üìù Step-by-Step Instructions

Follow the objectives below sequentially. Each objective provides a goal, the PowerShell script to execute, and guidance on analyzing its output.

### Objective One: Identify Uncommon Running Processes and Network Activity (Filtered)

Malicious programs often disguise themselves with obscure names, or they operate from unusual directories. To accelerate incident triage and reduce the analysis burden, analysts employ filtering techniques that ignore the substantial "noise" generated by common, known processes (like svchost.exe or web browsers) and focus only on the applications that are unusual for the system to be running. This is an effective live response approach because it immediately flags processes that deviate from the normal baseline, whether or not they are currently establishing a Command and Control (C2) connection.

**Goal:** Execute the following filtered script, which excludes a predefined list of essential Windows processes, to isolate potentially hostile or suspicious applications currently running on your system. The output will list the remaining, uncommon processes and correlate them with their network endpoints, or clearly indicate if no active connection exists.

```powershell
# 1. Define the list of common, essential PROCESS NAMES (Executables) to be EXCLUDED.
# NOTE: This list now contains common *process names* instead of *service names*.
$commonProcessNames = @(
    "svchost",                   # Hosts many common Windows services
    "explorer",                  # Windows File Explorer and Desktop
    "dwm",                       # Desktop Window Manager
    "csrss",                     # Client Server Runtime Process
    "lsass",                     # Local Security Authority Process
    "smss",                      # Session Manager Subsystem
    "runtimebroker",             # Manages permissions for Windows Store apps
    "taskhostw",                 # Host Process for Windows Tasks
    "microsoft.photos",          # Windows Photos App (example user app)
    "chrome",                    # Google Chrome (example common app)
    "msedge",                    # Microsoft Edge (example common app)
    "powershell",                # PowerShell process
    "audiodg",                   # Windows Audio Device Graph Isolation
    "System",                    # The System process (PID 4)
    "services",                  # Services and Controller app
    "winlogon",                  # Windows Logon Application
    "SearchHost",                # Windows Search
    "SecurityHealthService"      # Windows Security Health Service
    # Add more common, known executable names (without the .exe) here.
)

# --- 1. Get ALL Running Processes ---
$allProcesses = Get-Process

# Parse netstat output into structured objects
$netstatParsed = (netstat -ano) | Select-String -Pattern "TCP|UDP" | ForEach-Object {
    $parts = $_.Line.Trim() -split '\s+'
    if ($parts.Count -ge 5) {
        [PSCustomObject]@{
            Protocol       = $parts[0]
            LocalAddress   = $parts[1]
            ForeignAddress = $parts[2]
            State          = if ($parts.Count -ge 5) {$parts[3]} else {""}
            ProcessId      = [int]$parts[-1]
        }
    }
}

# 2. Filter ALL running processes to exclude the common ones.
$uncommonRunningProcesses = $allProcesses | Where-Object {
    $BaseName = $_.ProcessName.ToLower() # Use the base name for filtering
    
    # Check if the process name is NOT in the exact exclusion list
    $BaseName -notin $commonProcessNames
}

$outputData = $uncommonRunningProcesses | ForEach-Object {
    $process = $_
    $processPID = $process.Id
    $processName = $process.ProcessName + ".exe"

    # Get all netstat entries matching this process's PID
    $netstatMatches = $netstatParsed | Where-Object {$_.ProcessId -eq $processPID}

    # If connections exist, create one row per connection
    if ($netstatMatches) {
        $netstatMatches | ForEach-Object {
            [PSCustomObject]@{
                ProcessName      = $processName
                PID              = $processPID
                LocalAddress     = $_.LocalAddress
                ForeignAddress   = $_.ForeignAddress
            }
        }
    }
    # If NO connections exist, create one row with "N/A" connection fields
    else {
        [PSCustomObject]@{
            ProcessName      = $processName
            PID              = $processPID
            LocalAddress     = "N/A (No active connection)"
            ForeignAddress   = "N/A (No active connection)"
        }
    }
}

# Final output in a table format, showing only UNCOMMON running processes.
$outputData | Format-Table -AutoSize
```

**How to Analyze the Output:**
The output is pre-filtered to show only processes not on the safe, excluded list. Therefore, every entry in this table is a high-priority target for investigation.
*   **Unknown Process Names:** Immediately research the `ProcessName` for every entry in the table. If you cannot account for the application (e.g., it is not a known application you explicitly installed), it is highly suspicious.
*   **Foreign Address:** If the process shows a specific IP address and port in the `Foreign Address` column, it indicates an active network connection, confirming potential C2 communication, data exfiltration, or network scanning activity. This PID requires immediate containment.
*   **"N/A (No active connection)":** Do not ignore these processes. The malware may be fileless (memory-resident), only connect intermittently, or be designed for local reconnaissance only. Proceed to Objective Two immediately to find the path and owner of these N/A processes for disk inspection and validation.

### Objective Two: Find Executable Paths and Owners

Once you have identified a suspicious PID (Process ID) from Objective One, the next step is to determine exactly what program is running and who started it. This gives you the full path to the malicious executable and the account that launched it.

**Goal:** Use the PIDs from the previous step to find the full disk path of the executable and the account/user that owns the process.

```powershell
# ====================================================================================
# USER INPUT SECTION: CHANGE THIS VALUE BEFORE RUNNING THE SCRIPT
# Enter the Process ID (PID) to inspect (e.g., 1234)
# Example: To find a Chrome PID, open Task Manager, go to the Details tab, and look for 'chrome.exe'.
# ====================================================================================
[int]$PID = 24988  # <--- REPLACE 1234 WITH A LIVE CHROME PID

# --- 1. Validate and Retrieve Process Details (Path, Owner) ---

if (-not $PID) {
    Write-Error "A Process ID (PID) must be provided."
    exit
}

# Get core process details
$processDetails = Get-WmiObject -Class Win32_Process -Filter "ProcessId = $PID" | Select-Object -First 1

if (-not $processDetails) {
    Write-Error "No process found with Process ID $($PID)."
    exit
}

# Identify the executable name instead of a service name
$ProcessName = $processDetails.Name
$Path = $processDetails.ExecutablePath
$Owner = ($processDetails.GetOwner()).User

# --- 2. Get Network Connections (Local and Foreign Address) ---

# Netstat parsing logic - collecting only the necessary columns
$netstatParsed = (netstat -ano) | Select-String -Pattern "TCP|UDP" | ForEach-Object {
    $parts = $_.Line.Trim() -split '\s+'
    if ($parts.Count -ge 5) {
        [PSCustomObject]@{
            LocalAddress   = $parts[1]
            ForeignAddress = $parts[2]
            ProcessId      = [int]$parts[-1]
        }
    }
}

$netstatMatches = $netstatParsed | Where-Object {$_.ProcessId -eq $PID}

# --- 3. Flatten and Output Data ---

$outputData = @()

if ($netstatMatches) {
    # Create one row per network connection
    $netstatMatches | ForEach-Object {
        $outputData += [PSCustomObject]@{
            ProcessName       = $ProcessName
            PID               = $PID
            ExecutablePath    = $Path
            StartedBy         = $Owner
            LocalAddress      = $_.LocalAddress
            ForeignAddress    = $_.ForeignAddress
        }
    }
} else {
    # Create a single row if no connections are found
    $outputData += [PSCustomObject]@{
        ProcessName       = $ProcessName
        PID               = $PID
        ExecutablePath    = $Path
        StartedBy         = $Owner
        LocalAddress      = "N/A (No active connection)"
        ForeignAddress    = "N/A (No active connection)"
    }
}

# Final output in a table format
$outputData | Format-Table -AutoSize
```

**How to Analyze the Output:**
*   **Suspicious Paths:** Look for executables running from temporary folders (`C:\Users\<User>\AppData\Local\Temp`), user folders that should not contain executables, or paths that are misspelled to look like system folders.
*   **Unusual Owners:** If a process is owned by a `SYSTEM` or `Administrator` account but is running from a path typically reserved for user applications, it is highly suspicious.

### Objective Three: Check for Persistence and Initiate Containment

This objective is executed in two critical parts: first, determining if the suspicious process is configured to automatically restart (Persistence Check), and second, immediately blocking its ability to communicate externally (Containment). The provided script performs a comprehensive persistence check across three major areas: Registry Run keys, Startup folders, and Windows Services, providing a high-fidelity assessment of whether the threat is configured to survive a reboot.

**Goal:** Determine if the executable from Objective Two is configured to run at startup, and then isolate its network connection to prevent ongoing Command and Control (C2) communication.

```powershell
# ===========================================================================
# USER INPUT SECTION: CHANGE THIS VALUE BEFORE RUNNING THE SCRIPT
# Replace the placeholder path with the actual ExecutablePath you want to check.
# ===========================================================================
[string]$ExecutablePathToCheck = "C:\Windows\System32\SecurityHealthSystray.exe" # <--- INSERT YOUR PATH HERE

function Get-StartupStatus {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ExecutablePath
    )

    $FileName = Split-Path -Path $ExecutablePath -Leaf
    $StartupStatus = "No (Manual or Scheduled Task)" # Default status

    # Define persistence locations
    $StartupKeys = @(
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"
    )
    $StartupFolders = @(
        "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup",
        "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
    )

    # 1. Check Registry Run Keys
    foreach ($key in $StartupKeys) {
        try {
            $RegEntries = Get-ItemProperty -Path $key -ErrorAction Stop | Select-Object *
            
            # Check if any value data contains the full path or just the filename
            $match = $RegEntries.PSObject.Properties | Where-Object { 
                # Use -clike (case-insensitive like) for robustness
                $_.Value -clike "*$ExecutablePath*" -or $_.Value -clike "*$FileName*"
            }

            if ($match) {
                return "Yes (Registry: $($key.Split(':')[-1]))"
            }
        }
        catch {
            # Key not found or access denied, safely continue
        }
    }

    # 2. Check Startup Folders
    foreach ($folder in $StartupFolders) {
        $StartupFiles = Get-ChildItem -Path $folder -Recurse -ErrorAction SilentlyContinue | Where-Object { 
            ($_.Name -clike "*$FileName*") -and ($_.PSIsContainer -eq $false) 
        }
        
        if ($StartupFiles) {
            return "Yes (Startup Folder)"
        }
    }
    
    # 3. Check for associated Windows Service with Automatic start type
    try {
        $serviceMatch = Get-WmiObject -Class Win32_Service | Where-Object { 
            $_.PathName -clike "*$ExecutablePath*" -or $_.PathName -clike "*$FileName*" 
        } | Select-Object -First 1

        if ($serviceMatch -and $serviceMatch.StartMode -eq "Auto") {
            return "Yes (Windows Service: Automatic)"
        }
    }
    catch {
        # WMI error during service path lookup
    }

    # If no matches found after all checks
    return $StartupStatus
}


# ===========================================================================
# EXECUTION
# ===========================================================================

# Call the function with the user-defined path and output the result
$Result = Get-StartupStatus -ExecutablePath $ExecutablePathToCheck

# Final output in a clear format
[PSCustomObject]@{
    Executable = $ExecutablePathToCheck
    RunsAtStartup = $Result.Split(' ')[0] # Yes or No
    ConfigurationLocation = $Result.Split(' ', 2)[-1] # The source (Registry, Folder, etc.)
} | Format-Table -AutoSize
```

**How to Analyze the Output:**
*   **Persistence Check:** The output of the top block clearly indicates `RunsAtStartup` (`Yes` or `No`) and the `ConfigurationLocation` (e.g., `Registry: Run` or `Windows Service: Automatic`). If the result is "Yes", the malware is persistent, and you must manually remove the configuration entry found in the `ConfigurationLocation` in the next step (Objective Four). If the result is "No", the threat is not automatically running at startup, but you should still proceed to termination and deletion.

### Objective Four: Purge the Process, Persistence, and Files (Eradication)

This is the Eradication phase, which begins with the critical step of Containment to ensure the threat cannot communicate or spread while you remove it. You must ensure the network connection is severed, the process is stopped, the persistence mechanism is destroyed, and the file is deleted.

**Goal:** Quarantine the running process via the firewall, stop the process, remove the auto-start entry, and delete the malicious file from the disk.

#### Step 4.0: Quarantine the Program (Containment)

Before terminating the process, you must isolate it to prevent potential last-minute actions by the attacker or further data exfiltration. Since you have the exact file path from Objective Two, you can use the built-in Windows firewall to block all traffic for that specific program.

```powershell
function Block-ProcessNetworkAccess {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ExecutablePath,

        [Parameter(Mandatory=$true)]
        [string]$RuleName
    )
    
    # 1. Block OUTBOUND connections for the executable
    Write-Host "Creating OUTBOUND block rule: '$($RuleName) - Outbound'..."
    New-NetFirewallRule -DisplayName "$($RuleName) - Outbound" `
        -Name "$($RuleName)-Out" `
        -Direction Outbound `
        -Program "$ExecutablePath" `
        -Action Block `
        -Profile Any `
        -Enabled True

    # 2. Block INBOUND connections for the executable
    Write-Host "Creating INBOUND block rule: '$($RuleName) - Inbound'..."
    New-NetFirewallRule -DisplayName "$($RuleName) - Inbound" `
        -Name "$($RuleName)-In" `
        -Direction Inbound `
        -Program "$ExecutablePath" `
        -Action Block `
        -Profile Any `
        -Enabled True
        
    Write-Host "`n‚úÖ Quarantine Successful: '$RuleName' rules created for '$ExecutablePath'." -ForegroundColor Green
    Write-Host "The process must be restarted (or killed) for these rules to fully take effect." -ForegroundColor Yellow
}

# =========================================================================
# EXAMPLE USAGE: MODIFY THIS SECTION
# You would use the ExecutablePath found in your previous analysis scripts.
# =========================================================================

# Define the path of the process to quarantine
$TargetProcessPath = "C:\Users\mike.mwiti\Downloads\Windows_running_processes.ps1"

# Define a unique name for the rules
$QuarantineRuleName = "QUARANTINE_BLOCK_SUSPICIOUS_APP"

# Execute the function
Block-ProcessNetworkAccess -ExecutablePath $TargetProcessPath -RuleName $QuarantineRuleName

# -------------------------------------------------------------------------
# TO REMOVE THE RULES LATER:
# Get-NetFirewallRule -DisplayName "QUARANTINE_BLOCK_SUSPICIOUS_APP - *" | Remove-NetFirewallRule
# -------------------------------------------------------------------------
```

#### Step 4.1: Terminate the Process

*   **Open Task Manager:** Press `Ctrl + Shift + Esc`.
*   **Find the Process:** Go to the `Details` tab and locate the PID (Process ID) identified in Objective One. Alternatively, find the Process Name (e.g., `suspicious.exe`).
*   **End the Process:** Right-click the process and select `End task` or `End process tree`. This immediately stops the running malware code.
*   **PowerShell Option (Advanced):** If the process resists termination, you can use the command: `Stop-Process -Id <PID> -Force` (replacing `<PID>` with the number).

#### Step 4.2: Disable Persistence

You must remove the entry that tells Windows to run the malware on startup. This step relies on the `ConfigurationLocation` found in Objective Three.

*   **If Registry Key:**
    *   **Open Registry Editor:** Press `Windows Key + R`, type `regedit`, and press `Enter`.
    *   **Navigate:** Navigate to the specific key reported in Objective Three (e.g., `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`).
    *   **Delete the Entry:** In the right-hand panel, find the value that contains the malicious executable path (from Objective Two). Right-click on that value and select `Delete`.
*   **If Startup Folder:**
    *   **Navigate:** Use File Explorer to navigate to the reported folder (e.g., `%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup`).
    *   **Delete the File:** Delete any suspicious shortcut files or executables related to the malware.
*   **If Windows Service (Automatic):**
    *   **Open Services:** Open the Services app (`services.msc`).
    *   **Disable and Stop:** Find the suspicious Service, right-click, select `Properties`, change the `Startup type` to `Disabled`, and then click `Stop`.

#### Step 4.3: Delete the Executable File

*   **Open File Explorer:** Press `Windows Key + E`.
*   **Navigate to the Path:** Using the `Executable Path` identified in Objective Two, navigate to the folder containing the malicious file.
    *   **Example Path:** `C:\Users\<User>\AppData\Local\Temp\suspicious.exe`
*   **Delete the File:** Right-click the file and select `Delete`. You may need to empty the Recycle Bin afterward.
*   **Handle Locked Files:** If Windows reports the file is in use, the process was not successfully terminated in Step 4.1. Reboot the machine and immediately repeat Steps 4.1 and 4.3. If the process is persistent, you will need to boot into Safe Mode or use a dedicated forensic boot environment to bypass the lock (since persistence mechanisms are often disabled in Safe Mode).

---

## ‚úÖ Expected Outcomes

Upon successful completion of this project, you will be able to:
*   Identify potentially malicious processes on a Windows system using filtered output.
*   Pinpoint the full path and owner of any suspicious executable.
*   Understand and locate common malware persistence mechanisms (Registry Run keys, Startup folders, Services).
*   Proactively block network communication for a specific malicious program using Windows Firewall.
*   Confidently terminate malicious processes, remove their persistence entries, and delete their executable files.
*   Have a clear, step-by-step methodology for initial incident containment and eradication on a compromised Windows system.

---

## üöÄ Further Exploration

*   **Implement Scheduled Tasks Check:** Expand Objective Three to include a check for persistence established via Windows Scheduled Tasks, which is another common method for malware to maintain access.
*   **YARA Rules Creation:** For a found malicious executable, learn how to create a YARA rule to identify similar malware on other systems.
*   **Memory Forensics:** Explore tools like Volatility Framework to perform deeper analysis of running processes and their memory artifacts for fileless malware.
*   **Automated Remediation:** Develop a more advanced script that automates the entire eradication process, taking a PID as input and performing all steps (with user confirmation at critical stages).
*   **Network Packet Capture:** Integrate `Wireshark` or `pktmon` (on Windows) to capture and analyze network traffic from suspicious processes, identifying C2 patterns.

---

## üí° Conclusion and Sources

Successfully purging a persistent threat requires discipline in tracing its communication (Objective One), mapping its identity (Objective Two), breaking its persistent launch mechanisms, and isolating its network connection (Objective Three). This process transitions the system from Containment into Eradication, restoring the machine to a clean state.
```
